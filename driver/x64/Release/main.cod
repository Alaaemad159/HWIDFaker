; Listing generated by Microsoft (R) Optimizing Compiler Version 19.14.26429.4 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	RealDiskDeviceControl
PUBLIC	NumTable
PUBLIC	SpoofedHWID
PUBLIC	HWIDGenerated
_BSS	SEGMENT
RealDiskDeviceControl DQ 01H DUP (?)
HWIDGenerated DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
NumTable DB	'123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ', 00H
	ORG $+4
SpoofedHWID DB	'XYXYXYYYYYXYXXYXYYYXXYYXXXXYYXYYYXYYX', 00H, 00H
_DATA	ENDS
PUBLIC	GetDriverObject
PUBLIC	SpoofSerialNumber
PUBLIC	StorageQueryCompletionRoutine
PUBLIC	SmartCompletionRoutine
PUBLIC	DiskDriverDispatch
PUBLIC	UnsupportedDispatch
PUBLIC	CreateDispatch
PUBLIC	CloseDispatch
PUBLIC	DriverEntry
PUBLIC	??_C@_1BK@NMHHIFPM@?$AA?2?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AA?2?$AAd?$AAi?$AAs?$AAk?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
EXTRN	__imp_RtlInitUnicodeString:PROC
EXTRN	__imp_KeQuerySystemTimePrecise:PROC
EXTRN	__imp_ExAllocatePool:PROC
EXTRN	__imp_ExFreePoolWithTag:PROC
EXTRN	__imp_IofCompleteRequest:PROC
EXTRN	__imp_RtlRandomEx:PROC
EXTRN	__imp_ObReferenceObjectByName:PROC
EXTRN	__imp_IoDriverObjectType:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$GetDriverObject DD imagerel $LN5
	DD	imagerel $LN5+76
	DD	imagerel $unwind$GetDriverObject
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$SpoofSerialNumber DD imagerel $LN20
	DD	imagerel $LN20+22
	DD	imagerel $unwind$SpoofSerialNumber
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$SpoofSerialNumber DD imagerel $LN20+22
	DD	imagerel $LN20+87
	DD	imagerel $chain$1$SpoofSerialNumber
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$SpoofSerialNumber DD imagerel $LN20+87
	DD	imagerel $LN20+260
	DD	imagerel $chain$3$SpoofSerialNumber
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$SpoofSerialNumber DD imagerel $LN20+260
	DD	imagerel $LN20+299
	DD	imagerel $chain$4$SpoofSerialNumber
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$SpoofSerialNumber DD imagerel $LN20+299
	DD	imagerel $LN20+307
	DD	imagerel $chain$5$SpoofSerialNumber
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$StorageQueryCompletionRoutine DD imagerel $LN25
	DD	imagerel $LN25+39
	DD	imagerel $unwind$StorageQueryCompletionRoutine
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$StorageQueryCompletionRoutine DD imagerel $LN25+39
	DD	imagerel $LN25+98
	DD	imagerel $chain$1$StorageQueryCompletionRoutine
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$StorageQueryCompletionRoutine DD imagerel $LN25+98
	DD	imagerel $LN25+118
	DD	imagerel $chain$2$StorageQueryCompletionRoutine
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$StorageQueryCompletionRoutine DD imagerel $LN25+118
	DD	imagerel $LN25+360
	DD	imagerel $chain$3$StorageQueryCompletionRoutine
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$StorageQueryCompletionRoutine DD imagerel $LN25+360
	DD	imagerel $LN25+365
	DD	imagerel $chain$4$StorageQueryCompletionRoutine
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$StorageQueryCompletionRoutine DD imagerel $LN25+365
	DD	imagerel $LN25+380
	DD	imagerel $chain$5$StorageQueryCompletionRoutine
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$StorageQueryCompletionRoutine DD imagerel $LN25+380
	DD	imagerel $LN25+426
	DD	imagerel $chain$6$StorageQueryCompletionRoutine
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$SmartCompletionRoutine DD imagerel $LN7
	DD	imagerel $LN7+61
	DD	imagerel $unwind$SmartCompletionRoutine
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$DiskDriverDispatch DD imagerel $LN12
	DD	imagerel $LN12+198
	DD	imagerel $unwind$DiskDriverDispatch
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$UnsupportedDispatch DD imagerel $LN4
	DD	imagerel $LN4+36
	DD	imagerel $unwind$UnsupportedDispatch
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CreateDispatch DD imagerel $LN4
	DD	imagerel $LN4+29
	DD	imagerel $unwind$CreateDispatch
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CloseDispatch DD imagerel $LN4
	DD	imagerel $LN4+29
	DD	imagerel $unwind$CloseDispatch
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$DriverEntry DD imagerel $LN7
	DD	imagerel $LN7+184
	DD	imagerel $unwind$DriverEntry
pdata	ENDS
;	COMDAT ??_C@_1BK@NMHHIFPM@?$AA?2?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AA?2?$AAd?$AAi?$AAs?$AAk?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1BK@NMHHIFPM@?$AA?2?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AA?2?$AAd?$AAi?$AAs?$AAk?$AA?$AA@FNODOBFM@ DB '\'
	DB	00H, 'D', 00H, 'r', 00H, 'i', 00H, 'v', 00H, 'e', 00H, 'r', 00H
	DB	'\', 00H, 'd', 00H, 'i', 00H, 's', 00H, 'k', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DriverEntry DD 080f02H
	DD	06001602H
	DD	0e640fH
	DD	0d340fH
	DD	0700b920fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CloseDispatch DD 040602H
	DD	06001602H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CreateDispatch DD 040602H
	DD	06001602H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$UnsupportedDispatch DD 040602H
	DD	06001602H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DiskDriverDispatch DD 0a1402H
	DD	06001608H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$SmartCompletionRoutine DD 040602H
	DD	06141602H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$StorageQueryCompletionRoutine DD 020022H
	DD	06181608H
	DD	imagerel $LN25
	DD	imagerel $LN25+39
	DD	imagerel $unwind$StorageQueryCompletionRoutine
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$StorageQueryCompletionRoutine DD 022H
	DD	imagerel $LN25+39
	DD	imagerel $LN25+98
	DD	imagerel $chain$1$StorageQueryCompletionRoutine
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$StorageQueryCompletionRoutine DD 022H
	DD	imagerel $LN25+98
	DD	imagerel $LN25+118
	DD	imagerel $chain$2$StorageQueryCompletionRoutine
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$StorageQueryCompletionRoutine DD 020522H
	DD	04d405H
	DD	imagerel $LN25+98
	DD	imagerel $LN25+118
	DD	imagerel $chain$2$StorageQueryCompletionRoutine
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$StorageQueryCompletionRoutine DD 020522H
	DD	0c6405H
	DD	imagerel $LN25+39
	DD	imagerel $LN25+98
	DD	imagerel $chain$1$StorageQueryCompletionRoutine
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$StorageQueryCompletionRoutine DD 040e22H
	DD	0d740eH
	DD	0a3405H
	DD	imagerel $LN25
	DD	imagerel $LN25+39
	DD	imagerel $unwind$StorageQueryCompletionRoutine
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$StorageQueryCompletionRoutine DD 050c02H
	DD	0f008420cH
	DD	0c004e006H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$SpoofSerialNumber DD 020022H
	DD	06001602H
	DD	imagerel $LN20
	DD	imagerel $LN20+22
	DD	imagerel $unwind$SpoofSerialNumber
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$SpoofSerialNumber DD 022H
	DD	imagerel $LN20+22
	DD	imagerel $LN20+87
	DD	imagerel $chain$1$SpoofSerialNumber
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$SpoofSerialNumber DD 040d22H
	DD	04e40dH
	DD	083405H
	DD	imagerel $LN20+22
	DD	imagerel $LN20+87
	DD	imagerel $chain$1$SpoofSerialNumber
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$SpoofSerialNumber DD 040f22H
	DD	05740fH
	DD	0a5405H
	DD	imagerel $LN20
	DD	imagerel $LN20+22
	DD	imagerel $unwind$SpoofSerialNumber
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$SpoofSerialNumber DD 020602H
	DD	060025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GetDriverObject DD 040602H
	DD	06001602H
	DD	030027206H
xdata	ENDS
; Function compile flags: /Ogtp
; File d:\vsaktuelleprojekte\hwid\driver\main.c
;	COMDAT DriverEntry
_TEXT	SEGMENT
diskDrvName$ = 64
DrvObject$1 = 96
DriverObject$ = 96
RegistryPath$ = 104
DriverEntry PROC					; COMDAT

; 207  : {

$LN7:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  0000f	48 8b fa	 mov	 rdi, rdx
  00012	48 8b d9	 mov	 rbx, rcx

; 208  : 		NTSTATUS        status = STATUS_SUCCESS;
; 209  : 
; 210  : 		UNICODE_STRING diskDrvName;
; 211  : 		RtlInitUnicodeString(&diskDrvName, L"\\Driver\\disk");

  00015	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1BK@NMHHIFPM@?$AA?2?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AA?2?$AAd?$AAi?$AAs?$AAk?$AA?$AA@FNODOBFM@
  0001c	48 8d 4c 24 40	 lea	 rcx, QWORD PTR diskDrvName$[rsp]
  00021	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 33   : 	if (NT_SUCCESS(ObReferenceObjectByName(DriverName, 0, NULL, 0, *IoDriverObjectType, KernelMode, NULL, &DrvObject)))

  00027	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_IoDriverObjectType
  0002e	48 8d 4c 24 60	 lea	 rcx, QWORD PTR DrvObject$1[rsp]
  00033	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00038	33 f6		 xor	 esi, esi
  0003a	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  0003f	48 8d 4c 24 40	 lea	 rcx, QWORD PTR diskDrvName$[rsp]
  00044	40 88 74 24 28	 mov	 BYTE PTR [rsp+40], sil
  00049	45 33 c9	 xor	 r9d, r9d
  0004c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0004f	45 33 c0	 xor	 r8d, r8d
  00052	33 d2		 xor	 edx, edx
  00054	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00057	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0005c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObReferenceObjectByName
  00062	85 c0		 test	 eax, eax
  00064	8b ce		 mov	 ecx, esi
  00066	48 0f 49 4c 24
	60		 cmovns	 rcx, QWORD PTR DrvObject$1[rsp]

; 212  : 
; 213  : 		PDRIVER_OBJECT diskDrvObj = GetDriverObject(&diskDrvName);
; 214  : 
; 215  : 		RealDiskDeviceControl = diskDrvObj->MajorFunction[IRP_MJ_DEVICE_CONTROL];

  0006c	48 8b 81 e0 00
	00 00		 mov	 rax, QWORD PTR [rcx+224]
  00073	48 89 05 00 00
	00 00		 mov	 QWORD PTR RealDiskDeviceControl, rax

; 216  : 
; 217  : 		diskDrvObj->DriverInit = &DriverEntry;

  0007a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:DriverEntry
  00081	48 89 41 58	 mov	 QWORD PTR [rcx+88], rax

; 218  : 		diskDrvObj->DriverStart = (PVOID)DriverObject;
; 219  : 		diskDrvObj->DriverSize = (ULONG)RegistryPath;
; 220  : 		diskDrvObj->FastIoDispatch = NULL;
; 221  : 		diskDrvObj->DriverStartIo = NULL;
; 222  : 		diskDrvObj->DriverUnload = NULL;
; 223  : 
; 224  : 		/*for (ULONG t = 0; t <= IRP_MJ_MAXIMUM_FUNCTION; t++)
; 225  : 			diskDrvObj->MajorFunction[t] = &UnsupportedDispatch;*/
; 226  : 
; 227  : 		diskDrvObj->MajorFunction[IRP_MJ_DEVICE_CONTROL] = &DiskDriverDispatch;

  00085	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:DiskDriverDispatch
  0008c	48 89 81 e0 00
	00 00		 mov	 QWORD PTR [rcx+224], rax

; 228  : 		/*diskDrvObj->MajorFunction[IRP_MJ_CREATE] = &CreateDispatch;
; 229  : 		diskDrvObj->MajorFunction[IRP_MJ_CLOSE] = &CloseDispatch;*/
; 230  : 
; 231  : 		return status;

  00093	33 c0		 xor	 eax, eax
  00095	48 89 59 18	 mov	 QWORD PTR [rcx+24], rbx

; 232  : }

  00099	48 8b 5c 24 68	 mov	 rbx, QWORD PTR [rsp+104]
  0009e	48 89 71 50	 mov	 QWORD PTR [rcx+80], rsi
  000a2	48 89 71 60	 mov	 QWORD PTR [rcx+96], rsi
  000a6	48 89 71 68	 mov	 QWORD PTR [rcx+104], rsi
  000aa	48 8b 74 24 70	 mov	 rsi, QWORD PTR [rsp+112]
  000af	89 79 20	 mov	 DWORD PTR [rcx+32], edi
  000b2	48 83 c4 50	 add	 rsp, 80			; 00000050H
  000b6	5f		 pop	 rdi
  000b7	c3		 ret	 0
DriverEntry ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\vsaktuelleprojekte\hwid\driver\main.c
;	COMDAT CloseDispatch
_TEXT	SEGMENT
DeviceObject$ = 48
Irp$ = 56
CloseDispatch PROC					; COMDAT

; 199  : {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b da	 mov	 rbx, rdx

; 200  : 	UNREFERENCED_PARAMETER(DeviceObject);
; 201  : 
; 202  : 	IoCompleteRequest(Irp, IO_NO_INCREMENT);

  00009	33 d2		 xor	 edx, edx
  0000b	48 8b cb	 mov	 rcx, rbx
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCompleteRequest

; 203  : 	return Irp->IoStatus.Status;

  00014	8b 43 30	 mov	 eax, DWORD PTR [rbx+48]

; 204  : }

  00017	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001b	5b		 pop	 rbx
  0001c	c3		 ret	 0
CloseDispatch ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\vsaktuelleprojekte\hwid\driver\main.c
;	COMDAT CreateDispatch
_TEXT	SEGMENT
DeviceObject$ = 48
Irp$ = 56
CreateDispatch PROC					; COMDAT

; 190  : {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b da	 mov	 rbx, rdx

; 191  : 	UNREFERENCED_PARAMETER(DeviceObject);
; 192  : 
; 193  : 	IoCompleteRequest(Irp, IO_NO_INCREMENT);

  00009	33 d2		 xor	 edx, edx
  0000b	48 8b cb	 mov	 rcx, rbx
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCompleteRequest

; 194  : 	return Irp->IoStatus.Status;

  00014	8b 43 30	 mov	 eax, DWORD PTR [rbx+48]

; 195  : }

  00017	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001b	5b		 pop	 rbx
  0001c	c3		 ret	 0
CreateDispatch ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\vsaktuelleprojekte\hwid\driver\main.c
;	COMDAT UnsupportedDispatch
_TEXT	SEGMENT
DeviceObject$ = 48
Irp$ = 56
UnsupportedDispatch PROC				; COMDAT

; 178  : {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b da	 mov	 rbx, rdx

; 179  : 	UNREFERENCED_PARAMETER(DeviceObject);
; 180  : 
; 181  : 	Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

  00009	c7 42 30 bb 00
	00 c0		 mov	 DWORD PTR [rdx+48], -1073741637 ; ffffffffc00000bbH

; 182  : 	IoCompleteRequest(Irp, IO_NO_INCREMENT);

  00010	48 8b cb	 mov	 rcx, rbx
  00013	33 d2		 xor	 edx, edx
  00015	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCompleteRequest

; 183  : 	return Irp->IoStatus.Status;

  0001b	8b 43 30	 mov	 eax, DWORD PTR [rbx+48]

; 184  : }

  0001e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00022	5b		 pop	 rbx
  00023	c3		 ret	 0
UnsupportedDispatch ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\vsaktuelleprojekte\hwid\driver\main.c
; File c:\program files (x86)\windows kits\10\include\10.0.17134.0\km\wdm.h
; File d:\vsaktuelleprojekte\hwid\driver\main.c
;	COMDAT DiskDriverDispatch
_TEXT	SEGMENT
DeviceObject$ = 48
Irp$ = 56
DiskDriverDispatch PROC					; COMDAT

; 125  : {

$LN12:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
; File c:\program files (x86)\windows kits\10\include\10.0.17134.0\km\wdm.h

; 30868:     return Irp->Tail.Overlay.CurrentStackLocation;

  00014	48 8b ba b8 00
	00 00		 mov	 rdi, QWORD PTR [rdx+184]
; File d:\vsaktuelleprojekte\hwid\driver\main.c

; 125  : {

  0001b	48 8b f2	 mov	 rsi, rdx
  0001e	48 8b e9	 mov	 rbp, rcx

; 126  : 	PIO_STACK_LOCATION Io = IoGetCurrentIrpStackLocation(Irp);
; 127  : 
; 128  : 	switch (Io->Parameters.DeviceIoControl.IoControlCode)

  00021	8b 47 18	 mov	 eax, DWORD PTR [rdi+24]
  00024	3d 88 c0 07 00	 cmp	 eax, 508040		; 0007c088H
  00029	74 4b		 je	 SHORT $LN6@DiskDriver
  0002b	3d 00 14 2d 00	 cmp	 eax, 2954240		; 002d1400H
  00030	75 73		 jne	 SHORT $LN2@DiskDriver

; 129  : 	{
; 130  : 	case IOCTL_STORAGE_QUERY_PROPERTY:
; 131  : 	{
; 132  : 		PSTORAGE_PROPERTY_QUERY query = (PSTORAGE_PROPERTY_QUERY)Irp->AssociatedIrp.SystemBuffer;
; 133  : 
; 134  : 		if (query->PropertyId == StorageDeviceProperty)

  00032	48 8b 42 18	 mov	 rax, QWORD PTR [rdx+24]
  00036	83 38 00	 cmp	 DWORD PTR [rax], 0
  00039	75 6a		 jne	 SHORT $LN2@DiskDriver

; 135  : 		{
; 136  : 			Io->Control = 0;
; 137  : 			Io->Control |= SL_INVOKE_ON_SUCCESS;
; 138  : 
; 139  : 			PVOID OldContext = Io->Context;

  0003b	48 8b 5f 40	 mov	 rbx, QWORD PTR [rdi+64]

; 140  : 			Io->Context = (PVOID)ExAllocatePool(NonPagedPool, sizeof(REQUEST_STRUCT));

  0003f	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00044	33 c9		 xor	 ecx, ecx
  00046	c6 47 03 40	 mov	 BYTE PTR [rdi+3], 64	; 00000040H
  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePool

; 141  : 			REQUEST_STRUCT *pRequest = (REQUEST_STRUCT*)Io->Context;
; 142  : 			pRequest->OldRoutine = Io->CompletionRoutine;

  00050	48 8b 4f 38	 mov	 rcx, QWORD PTR [rdi+56]
  00054	48 89 47 40	 mov	 QWORD PTR [rdi+64], rax
  00058	48 89 08	 mov	 QWORD PTR [rax], rcx

; 143  : 			pRequest->OldContext = OldContext;

  0005b	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx

; 144  : 			pRequest->OutputBufferLength = Io->Parameters.DeviceIoControl.OutputBufferLength;

  0005f	8b 4f 08	 mov	 ecx, DWORD PTR [rdi+8]
  00062	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 145  : 			pRequest->StorageDescriptor = (PSTORAGE_DEVICE_DESCRIPTOR)Irp->AssociatedIrp.SystemBuffer;

  00065	48 8b 4e 18	 mov	 rcx, QWORD PTR [rsi+24]
  00069	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 146  : 
; 147  : 			Io->CompletionRoutine = (PIO_COMPLETION_ROUTINE)StorageQueryCompletionRoutine;

  0006d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:StorageQueryCompletionRoutine

; 148  : 		}
; 149  : 
; 150  : 		break;

  00074	eb 2b		 jmp	 SHORT $LN10@DiskDriver
$LN6@DiskDriver:

; 151  : 
; 152  : 	}
; 153  : 
; 154  : 	case SMART_RCV_DRIVE_DATA:
; 155  : 	{
; 156  : 		Io->Control = 0;
; 157  : 		Io->Control |= SL_INVOKE_ON_SUCCESS;
; 158  : 
; 159  : 		PVOID OldContext = Io->Context;

  00076	48 8b 5f 40	 mov	 rbx, QWORD PTR [rdi+64]

; 160  : 		Io->Context = (PVOID)ExAllocatePool(NonPagedPool, sizeof(REQUEST_STRUCT));

  0007a	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  0007f	33 c9		 xor	 ecx, ecx
  00081	c6 47 03 40	 mov	 BYTE PTR [rdi+3], 64	; 00000040H
  00085	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePool

; 161  : 		REQUEST_STRUCT *pRequest = (REQUEST_STRUCT*)Io->Context;
; 162  : 		pRequest->OldRoutine = Io->CompletionRoutine;

  0008b	48 8b 4f 38	 mov	 rcx, QWORD PTR [rdi+56]
  0008f	48 89 47 40	 mov	 QWORD PTR [rdi+64], rax
  00093	48 89 08	 mov	 QWORD PTR [rax], rcx

; 163  : 		pRequest->OldContext = OldContext;

  00096	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx

; 164  : 
; 165  : 		Io->CompletionRoutine = (PIO_COMPLETION_ROUTINE)SmartCompletionRoutine;

  0009a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:SmartCompletionRoutine
$LN10@DiskDriver:

; 166  : 
; 167  : 		break;
; 168  : 	}
; 169  : 	}
; 170  : 
; 171  : 	return RealDiskDeviceControl(DeviceObject, Irp);

  000a1	48 89 47 38	 mov	 QWORD PTR [rdi+56], rax
$LN2@DiskDriver:
  000a5	48 8b d6	 mov	 rdx, rsi
  000a8	48 8b cd	 mov	 rcx, rbp

; 172  : }

  000ab	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000b0	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  000b5	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000ba	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000be	5f		 pop	 rdi

; 166  : 
; 167  : 		break;
; 168  : 	}
; 169  : 	}
; 170  : 
; 171  : 	return RealDiskDeviceControl(DeviceObject, Irp);

  000bf	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR RealDiskDeviceControl
DiskDriverDispatch ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\vsaktuelleprojekte\hwid\driver\main.c
;	COMDAT SmartCompletionRoutine
_TEXT	SEGMENT
DeviceObject$ = 48
Irp$ = 56
Context$ = 64
SmartCompletionRoutine PROC				; COMDAT

; 105  : {

$LN7:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b da	 mov	 rbx, rdx

; 106  : 	UNREFERENCED_PARAMETER(DeviceObject);
; 107  : 
; 108  : 	PIO_COMPLETION_ROUTINE OldCompletionRoutine = NULL;
; 109  : 	PVOID OldContext = NULL;
; 110  : 
; 111  : 	if (Context != NULL)

  00009	4d 85 c0	 test	 r8, r8
  0000c	74 1d		 je	 SHORT $LN4@SmartCompl

; 112  : 	{
; 113  : 		REQUEST_STRUCT* pRequest = (REQUEST_STRUCT*)Context;
; 114  : 		OldCompletionRoutine = pRequest->OldRoutine;
; 115  : 		OldContext = pRequest->OldContext;
; 116  : 		ExFreePool(Context);

  0000e	33 d2		 xor	 edx, edx
  00010	49 8b c8	 mov	 rcx, r8
  00013	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag

; 120  : 
; 121  : 	return Irp->IoStatus.Status;
; 122  : }

  00019	b8 bb 00 00 c0	 mov	 eax, -1073741637	; ffffffffc00000bbH
  0001e	c7 43 30 bb 00
	00 c0		 mov	 DWORD PTR [rbx+48], -1073741637 ; ffffffffc00000bbH
  00025	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00029	5b		 pop	 rbx
  0002a	c3		 ret	 0
$LN4@SmartCompl:

; 117  : 	}
; 118  : 
; 119  : 	Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

  0002b	c7 42 30 bb 00
	00 c0		 mov	 DWORD PTR [rdx+48], -1073741637 ; ffffffffc00000bbH

; 120  : 
; 121  : 	return Irp->IoStatus.Status;
; 122  : }

  00032	b8 bb 00 00 c0	 mov	 eax, -1073741637	; ffffffffc00000bbH
  00037	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003b	5b		 pop	 rbx
  0003c	c3		 ret	 0
SmartCompletionRoutine ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\vsaktuelleprojekte\hwid\driver\main.c
;	COMDAT StorageQueryCompletionRoutine
_TEXT	SEGMENT
DeviceObject$ = 80
Seed$1 = 88
Irp$ = 88
Context$ = 96
StorageQueryCompletionRoutine PROC			; COMDAT

; 74   : {

$LN25:
  00000	40 55		 push	 rbp
  00002	41 54		 push	 r12
  00004	41 56		 push	 r14
  00006	41 57		 push	 r15
  00008	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000c	48 8b ea	 mov	 rbp, rdx
  0000f	4c 8b f9	 mov	 r15, rcx

; 75   : 	PIO_COMPLETION_ROUTINE OldCompletionRoutine = NULL;
; 76   : 	PVOID OldContext = NULL;
; 77   : 	ULONG OutputBufferLength = 0;
; 78   : 	PSTORAGE_DEVICE_DESCRIPTOR descriptor = NULL;
; 79   : 
; 80   : 	if (Context != NULL)

  00012	4d 85 c0	 test	 r8, r8
  00015	0f 84 81 01 00
	00		 je	 $LN4@StorageQue

; 81   : 	{
; 82   : 		REQUEST_STRUCT* pRequest = (REQUEST_STRUCT*)Context;
; 83   : 		OldCompletionRoutine = pRequest->OldRoutine;

  0001b	4d 8b 30	 mov	 r14, QWORD PTR [r8]

; 84   : 		OldContext = pRequest->OldContext;
; 85   : 		OutputBufferLength = pRequest->OutputBufferLength;
; 86   : 		descriptor = pRequest->StorageDescriptor;
; 87   : 
; 88   : 		ExFreePool(Context);

  0001e	33 d2		 xor	 edx, edx
  00020	4d 8b 60 08	 mov	 r12, QWORD PTR [r8+8]
  00024	49 8b c8	 mov	 rcx, r8
  00027	48 89 5c 24 50	 mov	 QWORD PTR [rsp+80], rbx
  0002c	49 8b 58 18	 mov	 rbx, QWORD PTR [r8+24]
  00030	48 89 7c 24 68	 mov	 QWORD PTR [rsp+104], rdi
  00035	41 8b 78 10	 mov	 edi, DWORD PTR [r8+16]
  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag

; 89   : 	}
; 90   : 
; 91   : 	if (FIELD_OFFSET(STORAGE_DEVICE_DESCRIPTOR, SerialNumberOffset) < OutputBufferLength && descriptor->SerialNumberOffset > 0 && descriptor->SerialNumberOffset < OutputBufferLength)

  0003f	83 ff 18	 cmp	 edi, 24
  00042	0f 86 25 01 00
	00		 jbe	 $LN10@StorageQue
  00048	8b 43 18	 mov	 eax, DWORD PTR [rbx+24]
  0004b	85 c0		 test	 eax, eax
  0004d	0f 84 1a 01 00
	00		 je	 $LN10@StorageQue
  00053	3b c7		 cmp	 eax, edi
  00055	0f 83 12 01 00
	00		 jae	 $LN10@StorageQue

; 46   : 		if (!HWIDGenerated)

  0005b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR HWIDGenerated, 0

; 92   : 	{
; 93   : 		char* SerialNumber = ((char*)descriptor) + descriptor->SerialNumberOffset;

  00062	48 89 74 24 60	 mov	 QWORD PTR [rsp+96], rsi
  00067	48 8d 34 03	 lea	 rsi, QWORD PTR [rbx+rax]

; 46   : 		if (!HWIDGenerated)

  0006b	0f 85 f7 00 00
	00		 jne	 $LN23@StorageQue

; 47   : 	{
; 48   : 		HWIDGenerated = 1;
; 49   : 
; 50   : 		LARGE_INTEGER Seed;
; 51   : 		KeQuerySystemTimePrecise(&Seed);

  00071	48 8d 4c 24 58	 lea	 rcx, QWORD PTR Seed$1[rsp]
  00076	4c 89 6c 24 20	 mov	 QWORD PTR [rsp+32], r13
  0007b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR HWIDGenerated, 1
  00085	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeQuerySystemTimePrecise

; 52   : 
; 53   : 		for (int i = 0; i < strlen(SpoofedHWID); ++i)

  0008b	33 ff		 xor	 edi, edi
  0008d	4c 8d 2d 00 00
	00 00		 lea	 r13, OFFSET FLAT:SpoofedHWID
  00094	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  0009b	0f 1f 44 00 00	 npad	 5
$LL22@StorageQue:
  000a0	48 ff c0	 inc	 rax
  000a3	42 38 3c 28	 cmp	 BYTE PTR [rax+r13], dil
  000a7	75 f7		 jne	 SHORT $LL22@StorageQue
  000a9	48 85 c0	 test	 rax, rax
  000ac	0f 84 94 00 00
	00		 je	 $LN8@StorageQue
  000b2	49 8b dd	 mov	 rbx, r13
$LL9@StorageQue:

; 54   : 		{
; 55   : 
; 56   : 			if (SpoofedHWID[i] == 'Y')

  000b5	44 0f b6 03	 movzx	 r8d, BYTE PTR [rbx]
  000b9	41 80 f8 59	 cmp	 r8b, 89			; 00000059H
  000bd	75 26		 jne	 SHORT $LN18@StorageQue

; 57   : 			{
; 58   : 				SpoofedHWID[i] = RtlRandomEx(&Seed.LowPart) % 26 + 65;

  000bf	48 8d 4c 24 58	 lea	 rcx, QWORD PTR Seed$1[rsp]
  000c4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlRandomEx
  000ca	44 8b c0	 mov	 r8d, eax
  000cd	b8 4f ec c4 4e	 mov	 eax, 1321528399		; 4ec4ec4fH
  000d2	41 f7 e0	 mul	 r8d
  000d5	c1 ea 03	 shr	 edx, 3
  000d8	6b ca 1a	 imul	 ecx, edx, 26
  000db	44 2b c1	 sub	 r8d, ecx
  000de	41 80 c0 41	 add	 r8b, 65			; 00000041H
  000e2	44 88 03	 mov	 BYTE PTR [rbx], r8b
$LN18@StorageQue:

; 59   : 
; 60   : 			}
; 61   : 
; 62   : 			if (SpoofedHWID[i] == 'X')

  000e5	41 80 f8 58	 cmp	 r8b, 88			; 00000058H
  000e9	75 34		 jne	 SHORT $LN7@StorageQue

; 63   : 			{
; 64   : 				SpoofedHWID[i] = NumTable[RtlRandomEx(&Seed.LowPart) % (strlen(NumTable) - 1)];

  000eb	48 8d 4c 24 58	 lea	 rcx, QWORD PTR Seed$1[rsp]
  000f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlRandomEx
  000f6	8b c0		 mov	 eax, eax
  000f8	48 c7 c1 ff ff
	ff ff		 mov	 rcx, -1
  000ff	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:NumTable
$LL21@StorageQue:
  00106	48 ff c1	 inc	 rcx
  00109	41 80 3c 09 00	 cmp	 BYTE PTR [r9+rcx], 0
  0010e	75 f6		 jne	 SHORT $LL21@StorageQue
  00110	48 ff c9	 dec	 rcx
  00113	33 d2		 xor	 edx, edx
  00115	48 f7 f1	 div	 rcx
  00118	42 0f b6 04 0a	 movzx	 eax, BYTE PTR [rdx+r9]
  0011d	88 03		 mov	 BYTE PTR [rbx], al
$LN7@StorageQue:

; 52   : 
; 53   : 		for (int i = 0; i < strlen(SpoofedHWID); ++i)

  0011f	ff c7		 inc	 edi
  00121	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00128	48 ff c3	 inc	 rbx
  0012b	0f 1f 44 00 00	 npad	 5
$LL20@StorageQue:
  00130	48 ff c0	 inc	 rax
  00133	42 80 3c 28 00	 cmp	 BYTE PTR [rax+r13], 0
  00138	75 f6		 jne	 SHORT $LL20@StorageQue
  0013a	48 63 cf	 movsxd	 rcx, edi
  0013d	48 3b c8	 cmp	 rcx, rax
  00140	0f 82 6f ff ff
	ff		 jb	 $LL9@StorageQue
$LN8@StorageQue:

; 65   : 			}
; 66   : 		}
; 67   : 
; 68   : 	RtlCopyMemory((void*)serialNumber, (void*)SpoofedHWID, 21);

  00146	0f 10 05 00 00
	00 00		 movups	 xmm0, XMMWORD PTR SpoofedHWID
  0014d	4c 8b 6c 24 20	 mov	 r13, QWORD PTR [rsp+32]
  00152	0f 11 06	 movups	 XMMWORD PTR [rsi], xmm0
  00155	8b 05 10 00 00
	00		 mov	 eax, DWORD PTR SpoofedHWID+16
  0015b	89 46 10	 mov	 DWORD PTR [rsi+16], eax
  0015e	0f b6 05 14 00
	00 00		 movzx	 eax, BYTE PTR SpoofedHWID+20
  00165	88 46 14	 mov	 BYTE PTR [rsi+20], al
$LN23@StorageQue:
  00168	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
$LN10@StorageQue:
  0016d	48 8b 7c 24 68	 mov	 rdi, QWORD PTR [rsp+104]

; 94   : 
; 95   : 		SpoofSerialNumber(SerialNumber);
; 96   : 	}
; 97   : 
; 98   : 	if ((Irp->StackCount >(ULONG)1) && (OldCompletionRoutine != NULL))

  00172	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00177	4d 85 f6	 test	 r14, r14
  0017a	74 20		 je	 SHORT $LN4@StorageQue
  0017c	80 7d 42 01	 cmp	 BYTE PTR [rbp+66], 1
  00180	76 1a		 jbe	 SHORT $LN4@StorageQue

; 99   : 		return OldCompletionRoutine(DeviceObject, Irp, OldContext);

  00182	4d 8b c4	 mov	 r8, r12
  00185	48 8b d5	 mov	 rdx, rbp
  00188	49 8b cf	 mov	 rcx, r15
  0018b	49 8b c6	 mov	 rax, r14

; 102  : }

  0018e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00192	41 5f		 pop	 r15
  00194	41 5e		 pop	 r14
  00196	41 5c		 pop	 r12
  00198	5d		 pop	 rbp

; 99   : 		return OldCompletionRoutine(DeviceObject, Irp, OldContext);

  00199	48 ff e0	 rex_jmp rax
$LN4@StorageQue:

; 100  : 
; 101  : 	return STATUS_SUCCESS;

  0019c	33 c0		 xor	 eax, eax

; 102  : }

  0019e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  001a2	41 5f		 pop	 r15
  001a4	41 5e		 pop	 r14
  001a6	41 5c		 pop	 r12
  001a8	5d		 pop	 rbp
  001a9	c3		 ret	 0
StorageQueryCompletionRoutine ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\vsaktuelleprojekte\hwid\driver\main.c
;	COMDAT SpoofSerialNumber
_TEXT	SEGMENT
serialNumber$ = 64
Seed$1 = 72
SpoofSerialNumber PROC					; COMDAT

; 45   : {

$LN20:
  00000	40 56		 push	 rsi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 46   : 		if (!HWIDGenerated)

  00006	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR HWIDGenerated, 0
  0000d	48 8b f1	 mov	 rsi, rcx
  00010	0f 85 15 01 00
	00		 jne	 $LN18@SpoofSeria

; 47   : 	{
; 48   : 		HWIDGenerated = 1;

  00016	48 89 6c 24 50	 mov	 QWORD PTR [rsp+80], rbp

; 49   : 
; 50   : 		LARGE_INTEGER Seed;
; 51   : 		KeQuerySystemTimePrecise(&Seed);

  0001b	48 8d 4c 24 48	 lea	 rcx, QWORD PTR Seed$1[rsp]
  00020	48 89 7c 24 28	 mov	 QWORD PTR [rsp+40], rdi
  00025	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR HWIDGenerated, 1
  0002f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeQuerySystemTimePrecise

; 52   : 
; 53   : 		for (int i = 0; i < strlen(SpoofedHWID); ++i)

  00035	33 ff		 xor	 edi, edi
  00037	48 8d 2d 00 00
	00 00		 lea	 rbp, OFFSET FLAT:SpoofedHWID
  0003e	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
$LL17@SpoofSeria:
  00045	48 ff c0	 inc	 rax
  00048	40 38 3c 28	 cmp	 BYTE PTR [rax+rbp], dil
  0004c	75 f7		 jne	 SHORT $LL17@SpoofSeria
  0004e	48 85 c0	 test	 rax, rax
  00051	0f 84 ad 00 00
	00		 je	 $LN3@SpoofSeria
  00057	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  0005c	48 8b dd	 mov	 rbx, rbp
  0005f	4c 89 74 24 20	 mov	 QWORD PTR [rsp+32], r14
  00064	4c 8d 35 00 00
	00 00		 lea	 r14, OFFSET FLAT:NumTable
  0006b	0f 1f 44 00 00	 npad	 5
$LL4@SpoofSeria:

; 54   : 		{
; 55   : 
; 56   : 			if (SpoofedHWID[i] == 'Y')

  00070	44 0f b6 03	 movzx	 r8d, BYTE PTR [rbx]
  00074	41 80 f8 59	 cmp	 r8b, 89			; 00000059H
  00078	75 26		 jne	 SHORT $LN13@SpoofSeria

; 57   : 			{
; 58   : 				SpoofedHWID[i] = RtlRandomEx(&Seed.LowPart) % 26 + 65;

  0007a	48 8d 4c 24 48	 lea	 rcx, QWORD PTR Seed$1[rsp]
  0007f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlRandomEx
  00085	44 8b c0	 mov	 r8d, eax
  00088	b8 4f ec c4 4e	 mov	 eax, 1321528399		; 4ec4ec4fH
  0008d	41 f7 e0	 mul	 r8d
  00090	c1 ea 03	 shr	 edx, 3
  00093	6b ca 1a	 imul	 ecx, edx, 26
  00096	44 2b c1	 sub	 r8d, ecx
  00099	41 80 c0 41	 add	 r8b, 65			; 00000041H
  0009d	44 88 03	 mov	 BYTE PTR [rbx], r8b
$LN13@SpoofSeria:

; 59   : 
; 60   : 			}
; 61   : 
; 62   : 			if (SpoofedHWID[i] == 'X')

  000a0	41 80 f8 58	 cmp	 r8b, 88			; 00000058H
  000a4	75 33		 jne	 SHORT $LN2@SpoofSeria

; 63   : 			{
; 64   : 				SpoofedHWID[i] = NumTable[RtlRandomEx(&Seed.LowPart) % (strlen(NumTable) - 1)];

  000a6	48 8d 4c 24 48	 lea	 rcx, QWORD PTR Seed$1[rsp]
  000ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlRandomEx
  000b1	8b c0		 mov	 eax, eax
  000b3	48 c7 c1 ff ff
	ff ff		 mov	 rcx, -1
  000ba	66 0f 1f 44 00
	00		 npad	 6
$LL16@SpoofSeria:
  000c0	48 ff c1	 inc	 rcx
  000c3	41 80 3c 0e 00	 cmp	 BYTE PTR [r14+rcx], 0
  000c8	75 f6		 jne	 SHORT $LL16@SpoofSeria
  000ca	48 ff c9	 dec	 rcx
  000cd	33 d2		 xor	 edx, edx
  000cf	48 f7 f1	 div	 rcx
  000d2	42 0f b6 04 32	 movzx	 eax, BYTE PTR [rdx+r14]
  000d7	88 03		 mov	 BYTE PTR [rbx], al
$LN2@SpoofSeria:

; 52   : 
; 53   : 		for (int i = 0; i < strlen(SpoofedHWID); ++i)

  000d9	ff c7		 inc	 edi
  000db	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  000e2	48 ff c3	 inc	 rbx
$LL15@SpoofSeria:
  000e5	48 ff c0	 inc	 rax
  000e8	80 3c 28 00	 cmp	 BYTE PTR [rax+rbp], 0
  000ec	75 f7		 jne	 SHORT $LL15@SpoofSeria
  000ee	48 63 cf	 movsxd	 rcx, edi
  000f1	48 3b c8	 cmp	 rcx, rax
  000f4	0f 82 76 ff ff
	ff		 jb	 $LL4@SpoofSeria
  000fa	4c 8b 74 24 20	 mov	 r14, QWORD PTR [rsp+32]
  000ff	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
$LN3@SpoofSeria:

; 65   : 			}
; 66   : 		}
; 67   : 
; 68   : 	RtlCopyMemory((void*)serialNumber, (void*)SpoofedHWID, 21);

  00104	0f 10 05 00 00
	00 00		 movups	 xmm0, XMMWORD PTR SpoofedHWID

; 69   : 	}
; 70   : 	return STATUS_SUCCESS;

  0010b	48 8b 7c 24 28	 mov	 rdi, QWORD PTR [rsp+40]
  00110	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  00115	0f 11 06	 movups	 XMMWORD PTR [rsi], xmm0
  00118	8b 05 10 00 00
	00		 mov	 eax, DWORD PTR SpoofedHWID+16
  0011e	89 46 10	 mov	 DWORD PTR [rsi+16], eax
  00121	0f b6 05 14 00
	00 00		 movzx	 eax, BYTE PTR SpoofedHWID+20
  00128	88 46 14	 mov	 BYTE PTR [rsi+20], al
$LN18@SpoofSeria:

; 71   : }

  0012b	33 c0		 xor	 eax, eax
  0012d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00131	5e		 pop	 rsi
  00132	c3		 ret	 0
SpoofSerialNumber ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\vsaktuelleprojekte\hwid\driver\main.c
;	COMDAT GetDriverObject
_TEXT	SEGMENT
DriverName$ = 80
DrvObject$ = 88
GetDriverObject PROC					; COMDAT

; 31   : {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 32   : 	PDRIVER_OBJECT DrvObject;
; 33   : 	if (NT_SUCCESS(ObReferenceObjectByName(DriverName, 0, NULL, 0, *IoDriverObjectType, KernelMode, NULL, &DrvObject)))

  00006	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_IoDriverObjectType
  0000d	48 8d 54 24 58	 lea	 rdx, QWORD PTR DrvObject$[rsp]
  00012	48 89 54 24 38	 mov	 QWORD PTR [rsp+56], rdx
  00017	33 db		 xor	 ebx, ebx
  00019	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0001e	45 33 c9	 xor	 r9d, r9d
  00021	88 5c 24 28	 mov	 BYTE PTR [rsp+40], bl
  00025	45 33 c0	 xor	 r8d, r8d
  00028	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002b	33 d2		 xor	 edx, edx
  0002d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00030	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00035	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObReferenceObjectByName
  0003b	85 c0		 test	 eax, eax
  0003d	48 0f 49 5c 24
	58		 cmovns	 rbx, QWORD PTR DrvObject$[rsp]
  00043	48 8b c3	 mov	 rax, rbx

; 34   : 	{
; 35   : 		return DrvObject;
; 36   : 	}
; 37   : 
; 38   : 	return NULL;
; 39   : }

  00046	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0004a	5b		 pop	 rbx
  0004b	c3		 ret	 0
GetDriverObject ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17134.0\km\wdm.h
;	COMDAT IoGetCurrentIrpStackLocation
_TEXT	SEGMENT
Irp$ = 8
IoGetCurrentIrpStackLocation PROC			; COMDAT

; 30867:     NT_ASSERT(Irp->CurrentLocation <= Irp->StackCount + 1);
; 30868:     return Irp->Tail.Overlay.CurrentStackLocation;

  00000	48 8b 81 b8 00
	00 00		 mov	 rax, QWORD PTR [rcx+184]

; 30869: }

  00007	c3		 ret	 0
IoGetCurrentIrpStackLocation ENDP
_TEXT	ENDS
END
